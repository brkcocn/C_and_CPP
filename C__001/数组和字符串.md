## day5

### 数组：

​	相同数据类型的有序连续存储。

```c
int arr[10] = {1, 2, 23, 4, 5, 6 , 10, 7, 8, 9};

各个元素的内存地址 连续。

数组名为地址。也是数组首元素的地址。 arr == &arr[0];

数组大小：sizeof(arr));

数组元素的大小: sizeof(arr[0]));

数组元素个数： sizeof(arr)/ sizeof(arr[0]));

数组的第一个元素下标： 0

数组的最后一个元素下标： sizeof(arr)/ sizeof(arr[0]) - 1
```

数组初始化：

```c
int arr[12] = { 1, 2 ,4, 6, 76, 8, 90 ,4, 3, 6 , 6, 8 }; 【重点】

int arr[10] = { 1, 2 ,4, 6, 76, 8, 9 };  剩余未初始化的元素，默认 0 值。 【重点】

int arr[10] = { 0 }; 初始化一个全为 0 的数组。【重点】

int arr[] = {1, 2, 4, 6, 8}; 	编译器自动求取元素个数  【重点】

int arr[] = {0};  只有一个元素，值为0

int arr[10]; 
arr[0] = 5;
arr[1] = 6;
arr[3] = 7;	其余元素未被初始化，默认值 随机数。
```


练习：	数组元素逆序：


练习：	冒泡排序：

### 二维数组：

```c
定义语法：

int arr[2][3] = 
	{
	{2, 5, 8},
	{7, 9 10}
	};

int arr[3][5] = {{2, 3, 54, 56, 7 }, {2, 67, 4, 35, 9}, {1, 4, 16, 3, 78}};

打印：
	for(i = 0; i < 3; i++)		// 行
	{
		for(j = 0; j <5; j++)   // 列
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}		
```

大小：

```c++
数组大小: sizeof(arr);

一行大小: sizeof(arr[0])： 二维数组的一行，就是一个一维数组。

一个元素大小:sizeof(arr[0][0])		

行数：row = sizeof(arr)/ sizeof(arr[0])

列数：col = sizeof(arr[0])/ sizeof(arr[0][0])
```

地址合一：

```c
printf("%p\n", arr); == printf("%p\n", &arr[0]); == printf("%p\n", arr[0][0]);

数组的首地址 == 数组的首行地址 ==  数组的首元素地址 。
```


二维数组的初始化：

```c
1）常规初始化：

	int arr[3][5] = {{2, 3, 54, 56, 7 }, {2, 67, 4, 35, 9}, {1, 4, 16, 3, 78}};

2) 不完全初始化：

	int arr[3][5] = {{2, 3}, {2, 67, 4, }, {1, 4, 16, 78}};  未被初始化的数值为 0 

	int arr[3][5] = {0};	初始化一个 初值全为0的二维数组

	int arr[3][5] = {2, 3, 2, 67, 4, 1, 4, 16, 78};  系统自动分配行列。

3）不完全指定行列初始化：

	int arr[][] = {1, 3, 4, 6, 7};  二维数组定义必须指定列值。

  	int arr[][2] = { 1, 3, 4, 6, 7 };  可以不指定行值。
```


练习：求出5名学生3门功课的总成绩。（一个学生的总成绩。一门功课的总成绩）

快捷导入代码：

```c
VS -> 工具-> 代码片段管理器 -> Visual C++
```


多维数组：【了解】

	三维数组：[层][行][列]
	
	数组类型 数组名[层][行][列];
	
	int arr[3][3][4];
	
	{ {12, 3, 4, 5}
	  {12, 3, 4, 5} },
	
	{ {12, 3, 4, 5}
	  {12, 3, 4, 5} },
	
	{ {12, 3, 4, 5}
	  {12, 3, 4, 5} },
	
	for(i = 0; i < 3; i++)  层
	
		for (j = 0; j < 3; j++)  行
	
			for (k = 0; k<4; k++)  列
	
				printf("%d ", arr[i][j][k]);



### 字符串

#### 字符数组 和 字符串区别：

```c
字符数组： 
	char str[5] = {'h', 'e', 'l', 'l', 'o'};	

字符串：
	char str[6] = {'h', 'e', 'l', 'l', 'o', '\0'};

	char str[6] = "hello";

	printf("%s");	使用printf打印字符串的时候，必须碰到 \0 结束。
```


练习：键盘输入字符串，存至str[]中，统计每个字母出现的次数。



字符串获取 scanf：

```c
注意：	1）用于存储字符串的空间必须足够大，防止溢出。 char str[5];

	  2) 获取字符串，%s， 遇到空格 和 \n 终止。
          
      3)scanf 自动加\0
        
      4) stdin中会缓存scanf的 \n  ,读取字符字符串时要提前取走。    
          

借助“正则表达式”, 获取带有空格的字符串：scanf("%[^\n]", str);
```

#### 字符串读写函数：

```c
gets： 从键盘获取一个字符串， 返回字符串的首地址。 可以获取带有空格的字符串。(不读取换行) 

	char *gets(char *buf);

		参数：用来存储字符串的空间地址。 “可以是字符串常量

		返回值：返回实际获取到的字符串首地址。
```


```c
fgets: 从stdin获取一个字符串， 预留 \0 的存储空间。空间足够读 \n, 空间不足舍弃 \n  

	char *fgets(char *s, int size, FILE *stream);

		参1：用来存储字符串的空间地址。

		参2：描述空间的大小。

		参3：读取字符串的位置。	键盘 -> 标准输入：stdin

		返回值：返回实际获取到的字符串首地址。
```


```c
puts：将一个字符串写出到屏幕. 
    printf("%s", "hello"); / printf("hello\n"); / puts("hello");   
输出字符串后会自动添加 \n 换行符。

	int puts(const char *s);	

		参数：待写出到屏幕的字符串。

		返回值： 成功：非负数 0。 失败： -1.		
```


```c
fputs：将一个字符串写出到stdout.输出字符串后， 不添加 \n 换行符。

	int fputs(const char * str, FILE * stream);	

		参1：待写出到屏幕的字符串。		屏幕 ->标准输出： stdout

		参数：写出位置 stdout

		返回值： 成功：0。 失败： -1.
```


```c
strlen: 碰到 \0 结束。

	size_t strlen(const char *s);  “可以是字符串常量

		参： 待求长度的字符串

		返回：有效的字符个数。
```

练习：字符串追加：

### day7

### 指针和字符串：

```c
1）
	char str1[] = {'h', 'i', '\0'};			变量，可读可写

	char str2[] = "hi";				变量，可读可写

	char *str3 = "hi";				常量，只读

	str3变量中，存储的是常量区中字符串常量“hi”中首个字符‘h’的地址值。
     
    str3[1] = 'H';	// 错误！！

	char *str4 = {'h', 'i', '\0'};  // 错误！！！

2）
	当字符串（字符数组）， 做函数参数时， 不需要提供2个参数。 因为每个字符串都有 '\0'。
```

练习：比较两个字符串： strcmp()的实现

```c
	比较 str1 和 str2， 如果相同返回0， 不同则依次比较ASCII码，str1 > str2 返回1，否则返回-1
```

练习：字符串拷贝：

练习：在字符串中查找字符出现的位置：

练 习：字符串去空格。





练习：在 str中求substr 出现次数：

**strstr函数：** 在 str中，找substr出现的位置。

```c
char *strstr(char *str, char *substr)  

	参1： 原串

	参2： 子串

	返回值： 子串在原串中的位置。（地址值）；

		    如果没有： NULL
```

